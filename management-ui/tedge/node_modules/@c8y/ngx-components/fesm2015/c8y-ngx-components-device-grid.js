import { __decorate, __param, __awaiter } from 'tslib';
import { ElementRef, Injector, Input, Directive, ViewChild, forwardRef, Component, Inject, Injectable, EventEmitter, Output, NgModule } from '@angular/core';
import { QueriesUtil, InventoryService } from '@c8y/client';
import { TranslateService } from '@ngx-translate/core';
import { cloneDeep, get, map, sortBy, remove, transform, identity, assign, forEach } from 'lodash-es';
import { FilteringFormRendererContext, CellRendererContext, gettext, SendStatus, PushStatus, FilteringActionType, DataGridComponent, CommonModule, FormsModule, DeviceStatusModule, DataGridModule } from '@c8y/ngx-components';
import { UpgradeComponent } from '@angular/upgrade/static';
import { AssetSelectorModule } from '@c8y/ngx-components/assets-navigator';

// TODO: MTM-31785: find replacement for schema-form ng1 library
let SchemaFormComponent = class SchemaFormComponent extends UpgradeComponent {
    constructor(elementRef, injector) {
        super('c8ySchemaForm', elementRef, injector);
    }
};
SchemaFormComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Injector }
];
__decorate([
    Input()
], SchemaFormComponent.prototype, "schema", void 0);
__decorate([
    Input()
], SchemaFormComponent.prototype, "model", void 0);
__decorate([
    Input('form')
], SchemaFormComponent.prototype, "inputForm", void 0);
__decorate([
    Input('options')
], SchemaFormComponent.prototype, "inputOptions", void 0);
SchemaFormComponent = __decorate([
    Directive({
        selector: 'c8y-schema-form'
    })
], SchemaFormComponent);

let BaseFilteringFormRendererComponent = class BaseFilteringFormRendererComponent {
    constructor(context) {
        this.context = context;
    }
    ngOnInit() {
        const column = this.context.property;
        this.schema = cloneDeep(column.filteringConfig.schema);
        this.form = cloneDeep(column.filteringConfig.form);
        this.model = cloneDeep(column.externalFilterQuery || {});
        this.options = { formDefaults: { ngModelOptions: { debounce: 100 } } };
    }
    canApply() {
        return get(this.schemaFormComponent, '$componentScope.vm.ngForm.$invalid');
    }
    applyFilter() {
        this.context.applyFilter({
            externalFilterQuery: this.model
        });
    }
    resetFilter() {
        this.context.resetFilter();
    }
};
BaseFilteringFormRendererComponent.ctorParameters = () => [
    { type: FilteringFormRendererContext }
];
__decorate([
    ViewChild(forwardRef(() => SchemaFormComponent), { static: false })
], BaseFilteringFormRendererComponent.prototype, "schemaFormComponent", void 0);
BaseFilteringFormRendererComponent = __decorate([
    Component({
        template: "<c8y-schema-form\n  [schema]=\"schema\"\n  [form]=\"form\"\n  [model]=\"model\"\n  [options]=\"options\"\n></c8y-schema-form>\n<div class=\"data-grid__dropdown__footer d-flex separator-top\">\n  <button\n    class=\"btn btn-default btn-sm m-r-8 flex-grow\"\n    (click)=\"resetFilter()\"\n    title=\"{{ 'Reset' | translate }}\"\n    translate\n  >\n    Reset\n  </button>\n\n  <button\n    class=\"btn btn-primary btn-sm flex-grow\"\n    (click)=\"applyFilter()\"\n    [disabled]=\"canApply()\"\n    title=\"{{ 'Apply' | translate }}\"\n    translate\n  >\n    Apply\n  </button>\n</div>\n"
    })
], BaseFilteringFormRendererComponent);

class BaseDeviceGridColumn {
    constructor(config = {}) {
        this.filteringFormRendererComponent = BaseFilteringFormRendererComponent;
        Object.assign(this, config);
    }
}

let AlarmsCellRendererComponent = class AlarmsCellRendererComponent {
    constructor(context, deviceGridService) {
        this.context = context;
        this.deviceGridService = deviceGridService;
    }
};
AlarmsCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: DeviceGridService, decorators: [{ type: Inject, args: [forwardRef(() => DeviceGridService),] }] }
];
AlarmsCellRendererComponent = __decorate([
    Component({
        template: "<a class=\"listLink\"\n  [href]=\"deviceGridService.getAlarmsHref(context.item)\" \n>\n  <small class=\"status critical text-nowrap\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.critical\"\n  >\n    {{ context.item.c8y_ActiveAlarmsStatus?.critical }}\n    <i [c8yIcon]=\"'warning'\"></i>\n  </small>\n  <small class=\"status major text-nowrap\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.major\"\n  >\n    {{ context.item.c8y_ActiveAlarmsStatus?.major }}\n    <i [c8yIcon]=\"'exclamation-circle'\"></i>\n  </small>\n  <small class=\"status minor text-nowrap\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.minor\"\n  >\n    {{ context.item.c8y_ActiveAlarmsStatus?.minor }}\n    <i [c8yIcon]=\"'exclamation-circle'\"></i>\n  </small>\n  <small class=\"status warning text-nowrap\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.warning\"\n  >\n    {{ context.item.c8y_ActiveAlarmsStatus?.warning }}\n    <i [c8yIcon]=\"'circle'\"></i>\n  </small>\n</a>\n"
    }),
    __param(1, Inject(forwardRef(() => DeviceGridService)))
], AlarmsCellRendererComponent);

class AlarmsDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'alarms';
        this.header = gettext('Alarms');
        this.cellRendererComponent = AlarmsCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    critical: {
                        type: 'boolean'
                    },
                    major: {
                        type: 'boolean'
                    },
                    minor: {
                        type: 'boolean'
                    },
                    warning: {
                        type: 'boolean'
                    },
                    none: {
                        type: 'boolean'
                    }
                }
            },
            form: [
                {
                    type: 'template',
                    template: `<label><span translate>${gettext('Show devices with active')}</span>:</label>`
                },
                {
                    key: 'critical',
                    title: gettext('Critical alarms')
                },
                {
                    key: 'major',
                    title: gettext('Major alarms')
                },
                {
                    key: 'minor',
                    title: gettext('Minor alarms')
                },
                {
                    key: 'warning',
                    title: gettext('Warnings')
                },
                {
                    key: 'none',
                    title: gettext('No alarms')
                }
            ],
            getFilter(model) {
                const filter = {};
                const ors = [];
                if (model.critical) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.critical': { __gt: 0 } });
                }
                if (model.major) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.major': { __gt: 0 } });
                }
                if (model.minor) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.minor': { __gt: 0 } });
                }
                if (model.warning) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.warning': { __gt: 0 } });
                }
                if (model.none) {
                    ors.push({ __not: { __has: 'c8y_ActiveAlarmsStatus' } });
                    ors.push({
                        __and: map(['critical', 'major', 'minor', 'warning'], sev => {
                            const zero = {};
                            const has = { __not: { __has: undefined } };
                            const key = `c8y_ActiveAlarmsStatus.${sev}`;
                            zero[key] = 0;
                            has.__not.__has = key;
                            return { __or: [zero, has] };
                        })
                    });
                }
                if (ors.length) {
                    filter.__or = ors;
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [
                { path: 'c8y_ActiveAlarmsStatus.critical' },
                { path: 'c8y_ActiveAlarmsStatus.major' },
                { path: 'c8y_ActiveAlarmsStatus.minor' },
                { path: 'c8y_ActiveAlarmsStatus.warning' }
            ]
        };
    }
}

let GroupCellRendererComponent = class GroupCellRendererComponent {
    constructor(context, deviceGridService) {
        this.context = context;
        this.deviceGridService = deviceGridService;
    }
};
GroupCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: DeviceGridService, decorators: [{ type: Inject, args: [forwardRef(() => DeviceGridService),] }] }
];
GroupCellRendererComponent = __decorate([
    Component({
        template: "<span\n  title=\"{{\n    deviceGridService.getParentsNames(\n      context.item,\n      context.property.externalFilterQuery?.deviceGroupId\n    )\n  }}\"\n  class=\"text-truncate\"\n>\n  {{\n    deviceGridService.getParentsNames(\n      context.item,\n      context.property.externalFilterQuery?.deviceGroupId\n    )\n  }}\n</span>\n"
    }),
    __param(1, Inject(forwardRef(() => DeviceGridService)))
], GroupCellRendererComponent);

let GroupFilteringFormRendererComponent = class GroupFilteringFormRendererComponent {
    constructor(context) {
        this.context = context;
        this.preselected = [];
    }
    ngOnInit() {
        const column = this.context.property;
        this.model = cloneDeep(column.externalFilterQuery || {});
        this.preselected = this.model.selectedNodes || [];
    }
    applyFilter() {
        this.context.applyFilter({
            externalFilterQuery: this.model
        });
    }
    resetFilter() {
        this.context.resetFilter();
    }
    selectionChanged(nodes) {
        this.model.selectedNodes = nodes;
    }
};
GroupFilteringFormRendererComponent.ctorParameters = () => [
    { type: FilteringFormRendererContext }
];
GroupFilteringFormRendererComponent = __decorate([
    Component({
        template: "<c8y-asset-selector\n  [selected]=\"preselected\"\n  (onChange)=\"selectionChanged($event)\"\n></c8y-asset-selector>\n\n<div class=\"data-grid__dropdown__footer d-flex separator-top\">\n  <button\n    class=\"btn btn-default btn-sm m-r-8 flex-grow\"\n    (click)=\"resetFilter()\"\n    title=\"{{ 'Reset' | translate }}\"\n    translate\n  >\n    Reset\n  </button>\n\n  <button\n    class=\"btn btn-primary btn-sm flex-grow\"\n    (click)=\"applyFilter()\"\n    title=\"{{ 'Apply' | translate }}\"\n    translate\n  >\n    Apply\n  </button>\n</div>\n"
    })
], GroupFilteringFormRendererComponent);

class GroupDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'group';
        this.header = gettext('Group');
        this.cellRendererComponent = GroupCellRendererComponent;
        this.filteringFormRendererComponent = GroupFilteringFormRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            getFilter(model) {
                const filter = {};
                if (model.selectedNodes) {
                    filter.__or = model.selectedNodes.map((mo) => {
                        if (mo.c8y_DeviceQueryString) {
                            return { __useFilterQueryString: mo.c8y_DeviceQueryString };
                        }
                        return { __bygroupid: mo.id };
                    });
                }
                return filter;
            }
        };
        this.sortable = false;
    }
}

class ImeiDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const self = this;
        this.path = 'c8y_Mobile.imei';
        this.name = 'imei';
        this.header = gettext('IMEI');
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    imeis: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'imeis',
                    title: gettext('Show devices with IMEI'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'imeis[]',
                            notitle: true,
                            placeholder: gettext('e.g. 46543432321, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.imeis.length) {
                    filter[self.path] = { __in: model.imeis };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

let ModelCellRendererComponent = class ModelCellRendererComponent {
    constructor(context, deviceGridService) {
        this.context = context;
        this.deviceGridService = deviceGridService;
    }
};
ModelCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: DeviceGridService, decorators: [{ type: Inject, args: [forwardRef(() => DeviceGridService),] }] }
];
ModelCellRendererComponent = __decorate([
    Component({
        template: `
    {{ deviceGridService.getModel(context.item) }}
  `
    }),
    __param(1, Inject(forwardRef(() => DeviceGridService)))
], ModelCellRendererComponent);

class ModelDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const hardwareModelPath = 'c8y_Hardware.model';
        const vendingModelPath = 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo.model';
        this.name = 'model';
        this.header = gettext('Model');
        this.cellRendererComponent = ModelCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    models: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'models',
                    title: gettext('Show devices with model'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'models[]',
                            notitle: true,
                            placeholder: gettext('e.g. ModelName, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.models.length) {
                    filter.__or = {
                        [hardwareModelPath]: { __in: model.models },
                        [vendingModelPath]: { __in: model.models }
                    };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: hardwareModelPath }, { path: vendingModelPath }]
        };
    }
}

let NameCellRendererComponent = class NameCellRendererComponent {
    constructor(context, deviceGridService) {
        this.context = context;
        this.deviceGridService = deviceGridService;
    }
};
NameCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: DeviceGridService, decorators: [{ type: Inject, args: [forwardRef(() => DeviceGridService),] }] }
];
NameCellRendererComponent = __decorate([
    Component({
        template: `
    <a
      [href]="deviceGridService.getHref(context.item)"
      title="{{ deviceGridService.getProperName(context.item) }}"
      class="interact"
    >
      {{ deviceGridService.getProperName(context.item) }}
    </a>
  `
    }),
    __param(1, Inject(forwardRef(() => DeviceGridService)))
], NameCellRendererComponent);

class NameDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'name';
        this.path = 'name';
        this.header = gettext('Name');
        this.cellCSSClassName = "data-record-header" /* Header */;
        this.cellRendererComponent = NameCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    names: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'names',
                    title: gettext('Show devices with name'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'names[]',
                            notitle: true,
                            placeholder: gettext('e.g. My Device, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.names.length) {
                    filter.name = { __in: model.names };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

let RegistrationDateCellRendererComponent = class RegistrationDateCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
};
RegistrationDateCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext }
];
RegistrationDateCellRendererComponent = __decorate([
    Component({
        template: `
    {{ context.value | c8yDate }}
  `
    })
], RegistrationDateCellRendererComponent);

class RegistrationDateDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const self = this;
        this.path = 'creationTime';
        this.name = 'registrationDate';
        this.header = gettext('Registration date');
        this.cellRendererComponent = RegistrationDateCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    registrationDate: {
                        type: 'object',
                        properties: {
                            after: {
                                type: 'string',
                                format: 'datetime'
                            },
                            before: {
                                type: 'string',
                                format: 'datetime'
                            }
                        }
                    }
                }
            },
            form: [
                {
                    key: 'registrationDate.after',
                    title: gettext('Show devices registered after'),
                    maxDateKey: 'registrationDate.before'
                },
                {
                    key: 'registrationDate.before',
                    title: gettext('And before`date`'),
                    minDateKey: 'registrationDate.after'
                }
            ],
            getFilter(model) {
                const filter = {};
                const dates = model && model.registrationDate;
                if (dates && (dates.after || dates.before)) {
                    filter.__and = [];
                    if (dates.after) {
                        const after = self.formatDate(dates.after);
                        filter.__and.push({
                            __or: {
                                [self.path]: { __gt: after },
                                [`${self.path}.date`]: { __gt: after }
                            }
                        });
                    }
                    if (dates.before) {
                        const before = self.formatDate(dates.before);
                        filter.__and.push({
                            __or: {
                                [self.path]: { __lt: before },
                                [`${self.path}.date`]: { __lt: before }
                            }
                        });
                    }
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: `${this.path}.date` }, { path: this.path }]
        };
    }
    formatDate(dateToFormat) {
        return new Date(dateToFormat).toISOString();
    }
}

let SerialNumberCellRendererComponent = class SerialNumberCellRendererComponent {
    constructor(context, deviceGridService) {
        this.context = context;
        this.deviceGridService = deviceGridService;
    }
};
SerialNumberCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext },
    { type: DeviceGridService, decorators: [{ type: Inject, args: [forwardRef(() => DeviceGridService),] }] }
];
SerialNumberCellRendererComponent = __decorate([
    Component({
        template: `
    {{ deviceGridService.getSerialNumber(context.item) }}
  `
    }),
    __param(1, Inject(forwardRef(() => DeviceGridService)))
], SerialNumberCellRendererComponent);

class SerialNumberDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const hardwareSerialNumberPath = 'c8y_Hardware.serialNumber';
        const vendingSerialNumberPath = 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo.serial';
        this.name = 'serialNumber';
        this.header = gettext('Serial number');
        this.cellRendererComponent = SerialNumberCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    serialNumbers: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'serialNumbers',
                    title: gettext('Show devices with serial number'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'serialNumbers[]',
                            notitle: true,
                            placeholder: gettext('e.g. 54321-123, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.serialNumbers.length) {
                    filter.__or = {
                        [hardwareSerialNumberPath]: { __in: model.serialNumbers },
                        [vendingSerialNumberPath]: { __in: model.serialNumbers }
                    };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: hardwareSerialNumberPath }, { path: vendingSerialNumberPath }]
        };
    }
}

let StatusCellRendererComponent = class StatusCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
};
StatusCellRendererComponent.ctorParameters = () => [
    { type: CellRendererContext }
];
StatusCellRendererComponent = __decorate([
    Component({
        template: `
    <device-status [mo]="context.item"></device-status>
  `
    })
], StatusCellRendererComponent);

class StatusDeviceGridColumn extends BaseDeviceGridColumn {
    constructor() {
        super();
        const responseIntervalPath = 'c8y_RequiredAvailability.responseInterval';
        const responseIntervalLessThanOrEqualTo0 = { [responseIntervalPath]: { __le: 0 } };
        const responseIntervalNotDefined = { __not: { __has: responseIntervalPath } };
        const availabilityStatusPath = 'c8y_Availability.status';
        const availabilityStatusAvailable = { [availabilityStatusPath]: SendStatus.AVAILABLE };
        const availabilityStatusUnavailable = { [availabilityStatusPath]: SendStatus.UNAVAILABLE };
        const availabilityStatusMaintenance = { [availabilityStatusPath]: SendStatus.MAINTENANCE };
        const availabilityStatusNotDefined = { __not: { __has: availabilityStatusPath } };
        const connectionStatusPath = 'c8y_Connection.status';
        const connectionStatusConnected = { [connectionStatusPath]: PushStatus.CONNECTED };
        const connectionStatusDisconnected = { [connectionStatusPath]: PushStatus.DISCONNECTED };
        const connectionStatusMaintenance = { [connectionStatusPath]: PushStatus.MAINTENANCE };
        const deviceUnderMaintenance = {
            __or: [
                responseIntervalLessThanOrEqualTo0,
                availabilityStatusMaintenance,
                connectionStatusMaintenance
            ]
        };
        const deviceNotUnderMaintenance = {
            // using __and of __nots because backend does not support __not with __ors
            __and: [
                { __not: responseIntervalLessThanOrEqualTo0 },
                { __not: availabilityStatusMaintenance },
                { __not: connectionStatusMaintenance }
            ]
        };
        this.name = 'status';
        this.header = gettext('Status');
        this.dataType = "icon" /* Icon */;
        this.cellRendererComponent = StatusCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    sendOnline: {
                        type: 'boolean'
                    },
                    sendOffline: {
                        type: 'boolean'
                    },
                    sendUnknown: {
                        type: 'boolean'
                    },
                    sendNotMonitored: {
                        type: 'boolean'
                    },
                    pushOnline: {
                        type: 'boolean'
                    },
                    pushOffline: {
                        type: 'boolean'
                    },
                    pushNotMonitored: {
                        type: 'boolean'
                    },
                    maintenance: {
                        type: 'boolean'
                    }
                }
            },
            form: [
                {
                    type: 'template',
                    template: `<label><span translate>${gettext('Show devices with send status')}</span>:</label>`
                },
                {
                    key: 'sendOnline',
                    title: gettext('Online')
                },
                {
                    key: 'sendOffline',
                    title: gettext('Offline')
                },
                {
                    key: 'sendUnknown',
                    title: gettext('Unknown')
                },
                {
                    key: 'sendNotMonitored',
                    title: gettext('Not monitored')
                },
                {
                    type: 'template',
                    template: `<label><span translate>${gettext('Show devices with push status')}</span>:</label>`
                },
                {
                    key: 'pushOnline',
                    title: gettext('Online')
                },
                {
                    key: 'pushOffline',
                    title: gettext('Offline')
                },
                {
                    key: 'pushNotMonitored',
                    title: gettext('Not monitored')
                },
                {
                    type: 'template',
                    template: `<label><span translate>${gettext('Show devices with maintenance status')}</span>:</label>`
                },
                {
                    key: 'maintenance',
                    title: gettext('Device is under maintenance')
                }
            ],
            getFilter(model) {
                const filter = {};
                const ors = [];
                if (model) {
                    if (model.sendOnline) {
                        ors.push({
                            __and: [deviceNotUnderMaintenance, availabilityStatusAvailable]
                        });
                    }
                    if (model.sendOffline) {
                        ors.push({
                            __and: [deviceNotUnderMaintenance, availabilityStatusUnavailable]
                        });
                    }
                    if (model.sendUnknown) {
                        ors.push({
                            __and: [deviceNotUnderMaintenance, availabilityStatusNotDefined]
                        });
                    }
                    if (model.sendNotMonitored || model.pushNotMonitored) {
                        ors.push(responseIntervalNotDefined);
                    }
                    if (model.pushOnline) {
                        ors.push({
                            __and: [deviceNotUnderMaintenance, connectionStatusConnected]
                        });
                    }
                    if (model.pushOffline) {
                        ors.push({
                            __and: [deviceNotUnderMaintenance, connectionStatusDisconnected]
                        });
                    }
                    if (model.maintenance) {
                        ors.push(deviceUnderMaintenance);
                    }
                    if (ors.length) {
                        filter.__or = ors;
                    }
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: availabilityStatusPath }]
        };
    }
}

class SystemIdDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const self = this;
        this.path = 'id';
        this.name = 'systemId';
        this.header = gettext('System ID');
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    ids: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'ids',
                    title: gettext('Show devices with system ID'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'ids[]',
                            notitle: true,
                            placeholder: gettext('e.g. 10300, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.ids.length) {
                    filter[self.path] = { __in: model.ids };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

let DeviceGridService = class DeviceGridService {
    constructor(inventoryService, translateService) {
        this.inventoryService = inventoryService;
        this.translateService = translateService;
        this.GRID_CONFIG_DEFAULT_STORAGE_KEY = 'device-grid-config';
        this.DEFAULT_PAGE_SIZE = 20;
        this.queriesUtil = new QueriesUtil();
    }
    getDefaultColumns() {
        const defaultColumns = [
            new StatusDeviceGridColumn(),
            new NameDeviceGridColumn(),
            new ModelDeviceGridColumn(),
            new SerialNumberDeviceGridColumn(),
            new GroupDeviceGridColumn(),
            new RegistrationDateDeviceGridColumn(),
            new SystemIdDeviceGridColumn(),
            new ImeiDeviceGridColumn(),
            new AlarmsDeviceGridColumn()
        ];
        return defaultColumns;
    }
    getDefaultPagination() {
        return {
            pageSize: 10,
            currentPage: 1
        };
    }
    getInfiniteScrollPagination() {
        return {
            pageSize: 50,
            currentPage: 1
        };
    }
    getDefaultActionControls() {
        return [
            {
                type: "DELETE" /* Delete */,
                callback: (item) => this.delete(item)
            }
        ];
    }
    getDefaultBulkActionControls() {
        return [];
    }
    getProperName(device) {
        const { id, name } = device;
        return name ? name : this.translateService.instant('Device {{id}}', { id });
    }
    getModel(device) {
        const hardware = this.getHardware(device);
        return hardware && hardware.model;
    }
    getSerialNumber(device) {
        const hardware = this.getHardware(device);
        const serialPropertyName = this.isVendme(device) ? 'serial' : 'serialNumber';
        return hardware && hardware[serialPropertyName];
    }
    getParentsNames(device, featuredParentId) {
        const assetParentsReferences = device.assetParents.references;
        const assetParents = map(assetParentsReferences, 'managedObject');
        const sortedByName = sortBy(assetParents, ['name']);
        const featuredItems = remove(sortedByName, { id: featuredParentId });
        const items = featuredItems.concat(sortedByName);
        const names = map(items, 'name');
        return names.join(', ');
    }
    getHref(groupOrDevice, prefix = '#/') {
        if (groupOrDevice.c8y_IsDeviceGroup || groupOrDevice.c8y_IsDynamicGroup) {
            return `${prefix}group/${groupOrDevice.id}`;
        }
        return `${prefix}device/${groupOrDevice.id}`;
    }
    getAlarmsHref(device) {
        return `${this.getHref(device)}/alarms`;
    }
    getUserConfiguredColumns(columns) {
        const config = this.getConfig();
        if (config.columns.length > 0) {
            const reOrderedColumns = [];
            let noConfigColumns = [];
            try {
                noConfigColumns = columns.filter(col => !config.columns.includes(col));
                config.columns.forEach(({ visible, name, sortOrder }) => {
                    const columnToReorder = columns.find(col => col.name === name);
                    if (columnToReorder) {
                        columnToReorder.visible = visible;
                        columnToReorder.sortOrder = sortOrder;
                        reOrderedColumns.push(columnToReorder);
                    }
                });
            }
            catch (ex) {
                this.clearConfig();
            }
            return [...reOrderedColumns, ...noConfigColumns];
        }
        return columns;
    }
    delete(device) {
        console.log('should delete', device);
    }
    getData(columns, pagination, query = {}, withChildren = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = Object.assign({}, this.getDevicesFilters(columns, pagination, query), { withParents: true, withChildren });
            return this.inventoryService.list(filters);
        });
    }
    getCount(columns, pagination, query = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = Object.assign({}, this.getDevicesFilters(columns, pagination, query), { pageSize: 1, currentPage: 1 });
            return (yield this.inventoryService.list(filters)).paging.totalPages;
        });
    }
    getTotal(query = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = {
                q: this.queriesUtil.buildQuery(query),
                pageSize: 1,
                withTotalPages: true
            };
            return (yield this.inventoryService.list(filters)).paging.totalPages;
        });
    }
    getDeviceQueryString(columns, query) {
        let fullQuery = this.getQueryObj(columns);
        fullQuery = this.queriesUtil.addAndFilter(fullQuery, query);
        return this.queriesUtil.buildQuery(fullQuery);
    }
    getQueryObj(columns, defaultFilter = {}) {
        return transform(columns, (query, column) => this.extendQueryByColumn(query, column), Object.assign({ __filter: {}, __orderby: [] }, defaultFilter));
    }
    getConfig(key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY) {
        const config = JSON.parse(localStorage.getItem(key));
        if (config === null) {
            return { columns: [], pagination: { pageSize: this.DEFAULT_PAGE_SIZE, currentPage: 1 } };
        }
        return config;
    }
    saveConfig(config, key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY) {
        localStorage.setItem(key, JSON.stringify(config));
    }
    clearConfig(key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY) {
        localStorage.removeItem(key);
    }
    getHardware(device) {
        const hardwarePropertyName = this.isVendme(device)
            ? 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo'
            : 'c8y_Hardware';
        return device && device[hardwarePropertyName];
    }
    isVendme(device) {
        return device.type === 'com_nsn_startups_vendme_VendingMachine';
    }
    getDevicesFilters(columns, pagination, query) {
        return {
            q: this.getDeviceQueryString(columns, query),
            pageSize: pagination.pageSize,
            currentPage: pagination.currentPage,
            withChildren: false,
            withTotalPages: true
        };
    }
    extendQueryByColumn(query, column) {
        if (column.filterable && column.externalFilterQuery) {
            const getFilter = column.filteringConfig.getFilter || identity;
            const queryObj = getFilter(column.externalFilterQuery);
            if (queryObj.__or) {
                query.__filter.__and = query.__filter.__and || [];
                query.__filter.__and.push(queryObj);
            }
            else if (queryObj.__and && get(query, '__filter.__and')) {
                queryObj.__and.map(obj => query.__filter.__and.push(obj));
            }
            else {
                assign(query.__filter, queryObj);
            }
        }
        if (column.sortable && column.sortOrder) {
            const cs = {};
            forEach(column.sortingConfig.pathSortingConfigs, pathSortingConfig => {
                cs[pathSortingConfig.path] =
                    (column.sortOrder === 'asc' ? 1 : -1) * (pathSortingConfig.sortOrderModifier || 1);
            });
            query.__orderby.push(cs);
        }
        return query;
    }
};
DeviceGridService.ctorParameters = () => [
    { type: InventoryService },
    { type: TranslateService }
];
DeviceGridService = __decorate([
    Injectable()
], DeviceGridService);

let DeviceGridComponent = class DeviceGridComponent {
    constructor(deviceGridService) {
        this.deviceGridService = deviceGridService;
        this.title = gettext('Devices');
        this.loadMoreItemsLabel = gettext('Load more devices');
        this.loadingItemsLabel = gettext('Loading devicesâ€¦');
        this.selectable = false;
        this.baseQuery = {};
        this.showChildDevices = {};
        this.onColumnsChange = new EventEmitter();
        this.onDeviceQueryStringChange = new EventEmitter();
        this.itemsSelect = new EventEmitter();
        this.onChildDevices = new EventEmitter();
        this.columns = this.deviceGridService.getDefaultColumns();
        this.pagination = this.deviceGridService.getDefaultPagination();
        this.actionControls = this.deviceGridService.getDefaultActionControls();
        this.bulkActionControls = this.deviceGridService.getDefaultBulkActionControls();
        this.withChildren = false;
        this.serverSideDataCallback = this.onDataSourceModifier.bind(this);
    }
    set _columns(value) {
        if (value) {
            this.columns = this.deviceGridService.getUserConfiguredColumns(value);
        }
        else {
            this.columns = this.deviceGridService.getUserConfiguredColumns(this.deviceGridService.getDefaultColumns());
        }
    }
    set _pagination(value) {
        if (value) {
            this.pagination = value;
        }
        else {
            this.pagination = this.deviceGridService.getDefaultPagination();
        }
    }
    set _infiniteScroll(infiniteScroll) {
        this.infiniteScroll = infiniteScroll;
        this.pagination = this.deviceGridService.getInfiniteScrollPagination();
    }
    set _actionControls(value) {
        if (value) {
            this.actionControls = value;
        }
        else {
            this.actionControls = this.deviceGridService.getDefaultActionControls();
        }
    }
    set _bulkActionControls(value) {
        if (value) {
            this.bulkActionControls = value;
        }
        else {
            this.bulkActionControls = this.deviceGridService.getDefaultBulkActionControls();
        }
    }
    trackByName(_index, column) {
        return column.name;
    }
    onDataSourceModifier(dataSourceModifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let serverSideDataResult;
            const { res, data, paging } = yield this.deviceGridService.getData(dataSourceModifier.columns, dataSourceModifier.pagination, this.baseQuery, this.withChildren);
            const filteredSize = yield this.deviceGridService.getCount(dataSourceModifier.columns, dataSourceModifier.pagination, this.baseQuery);
            const size = yield this.deviceGridService.getTotal(this.baseQuery);
            this.onColumnsChange.emit(dataSourceModifier.columns);
            this.onDeviceQueryStringChange.emit(this.deviceGridService.getDeviceQueryString(dataSourceModifier.columns, this.baseQuery));
            serverSideDataResult = {
                res,
                data,
                paging,
                filteredSize,
                size
            };
            if (this.dataCallback) {
                serverSideDataResult = this.dataCallback(serverSideDataResult);
            }
            return serverSideDataResult;
        });
    }
    updateFiltering(columnNames, action) {
        const { type } = action;
        if (type === FilteringActionType.ResetFilter) {
            this.dataGrid.clearFilters();
        }
        else {
            this.dataGrid.updateFiltering(columnNames, action);
        }
    }
    configChange(config) {
        this.deviceGridService.saveConfig(config);
    }
};
DeviceGridComponent.ctorParameters = () => [
    { type: DeviceGridService }
];
__decorate([
    Input()
], DeviceGridComponent.prototype, "dataCallback", void 0);
__decorate([
    Input()
], DeviceGridComponent.prototype, "refresh", void 0);
__decorate([
    Input()
], DeviceGridComponent.prototype, "title", void 0);
__decorate([
    Input()
], DeviceGridComponent.prototype, "itemsSelectLimit", void 0);
__decorate([
    Input()
], DeviceGridComponent.prototype, "loadMoreItemsLabel", void 0);
__decorate([
    Input()
], DeviceGridComponent.prototype, "loadingItemsLabel", void 0);
__decorate([
    Input('columns')
], DeviceGridComponent.prototype, "_columns", null);
__decorate([
    Input('pagination')
], DeviceGridComponent.prototype, "_pagination", null);
__decorate([
    Input('infiniteScroll')
], DeviceGridComponent.prototype, "_infiniteScroll", null);
__decorate([
    Input('actionControls')
], DeviceGridComponent.prototype, "_actionControls", null);
__decorate([
    Input()
], DeviceGridComponent.prototype, "selectable", void 0);
__decorate([
    Input()
], DeviceGridComponent.prototype, "baseQuery", void 0);
__decorate([
    Input('bulkActionControls')
], DeviceGridComponent.prototype, "_bulkActionControls", null);
__decorate([
    Input()
], DeviceGridComponent.prototype, "showChildDevices", void 0);
__decorate([
    Output()
], DeviceGridComponent.prototype, "onColumnsChange", void 0);
__decorate([
    Output()
], DeviceGridComponent.prototype, "onDeviceQueryStringChange", void 0);
__decorate([
    Output()
], DeviceGridComponent.prototype, "itemsSelect", void 0);
__decorate([
    Output()
], DeviceGridComponent.prototype, "onChildDevices", void 0);
__decorate([
    ViewChild(DataGridComponent, { static: true })
], DeviceGridComponent.prototype, "dataGrid", void 0);
DeviceGridComponent = __decorate([
    Component({
        selector: 'c8y-device-grid',
        template: "<c8y-data-grid\n  [title]=\"title\"\n  [loadMoreItemsLabel]=\"loadMoreItemsLabel\"\n  [loadingItemsLabel]=\"loadingItemsLabel\"\n  [columns]=\"columns\"\n  [pagination]=\"pagination\"\n  [infiniteScroll]=\"infiniteScroll\"\n  [actionControls]=\"actionControls\"\n  [selectable]=\"selectable\"\n  [bulkActionControls]=\"bulkActionControls\"\n  [serverSideDataCallback]=\"serverSideDataCallback\"\n  [itemsSelectLimit]=\"itemsSelectLimit\"\n  (itemsSelect)=\"itemsSelect.emit($event)\"\n  (onConfigChange)=\"configChange($event)\"\n  [refresh]=\"refresh\"\n  [showChildDevices]=\"showChildDevices\"\n  (onChildDevices)=\"withChildren=$event;onChildDevices.emit($event)\"\n>\n  <div class=\"c8y-empty-state\">\n    <h1 c8yIcon=\"search\"></h1>\n    <div>\n      <p>\n        <strong>{{ 'No matching devices.' | translate }}</strong>\n      </p>\n      <small>{{ 'Refine your search terms' | translate }}</small>\n    </div>\n  </div>\n  <ng-container *ngFor=\"let column of columns; trackBy: trackByName\">\n    <c8y-column [name]=\"column.name\"></c8y-column>\n  </ng-container>\n</c8y-data-grid>\n"
    })
], DeviceGridComponent);

let DeviceGridModule = class DeviceGridModule {
};
DeviceGridModule = __decorate([
    NgModule({
        imports: [CommonModule, FormsModule, DeviceStatusModule, DataGridModule, AssetSelectorModule],
        declarations: [
            DeviceGridComponent,
            BaseFilteringFormRendererComponent,
            GroupFilteringFormRendererComponent,
            StatusCellRendererComponent,
            NameCellRendererComponent,
            ModelCellRendererComponent,
            SerialNumberCellRendererComponent,
            GroupCellRendererComponent,
            RegistrationDateCellRendererComponent,
            AlarmsCellRendererComponent,
            SchemaFormComponent
        ],
        exports: [
            DeviceGridComponent,
            BaseFilteringFormRendererComponent,
            GroupFilteringFormRendererComponent,
            StatusCellRendererComponent,
            NameCellRendererComponent,
            ModelCellRendererComponent,
            SerialNumberCellRendererComponent,
            GroupCellRendererComponent,
            RegistrationDateCellRendererComponent,
            AlarmsCellRendererComponent,
            SchemaFormComponent
        ],
        entryComponents: [
            DeviceGridComponent,
            BaseFilteringFormRendererComponent,
            GroupFilteringFormRendererComponent,
            StatusCellRendererComponent,
            NameCellRendererComponent,
            ModelCellRendererComponent,
            SerialNumberCellRendererComponent,
            GroupCellRendererComponent,
            RegistrationDateCellRendererComponent,
            AlarmsCellRendererComponent
        ],
        providers: [DeviceGridService]
    })
], DeviceGridModule);

class CustomDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const self = this;
        this.name = 'custom';
        this.header = gettext('Custom');
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    exists: {
                        type: 'boolean',
                        default: false,
                        title: gettext('Only rows where value is defined')
                    },
                    equals: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'exists'
                },
                {
                    key: 'equals',
                    title: gettext('Only rows where value equals to:'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'equals[]',
                            notitle: true,
                            placeholder: gettext('e.g. value, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.exists) {
                    filter.__has = self.path;
                }
                if (model.equals) {
                    filter[self.path] = { __in: model.equals };
                }
                return filter;
            }
        };
        this.sortable = true;
    }
    get sortingConfig() {
        return {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class TypeDeviceGridColumn extends BaseDeviceGridColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'type';
        this.path = 'type';
        this.header = gettext('Type');
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    types: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'types',
                    title: gettext('Show devices with type'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'types[]',
                            notitle: true,
                            placeholder: gettext('e.g. MyType, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter(model) {
                const filter = {};
                if (model.types.length) {
                    filter.type = { __in: model.types };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = { pathSortingConfigs: [{ path: 'type' }] };
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { AlarmsCellRendererComponent, AlarmsDeviceGridColumn, BaseDeviceGridColumn, BaseFilteringFormRendererComponent, CustomDeviceGridColumn, DeviceGridComponent, DeviceGridModule, DeviceGridService, GroupCellRendererComponent, GroupDeviceGridColumn, GroupFilteringFormRendererComponent, ImeiDeviceGridColumn, ModelCellRendererComponent, ModelDeviceGridColumn, NameCellRendererComponent, NameDeviceGridColumn, RegistrationDateCellRendererComponent, RegistrationDateDeviceGridColumn, SchemaFormComponent, SerialNumberCellRendererComponent, SerialNumberDeviceGridColumn, StatusCellRendererComponent, StatusDeviceGridColumn, SystemIdDeviceGridColumn, TypeDeviceGridColumn, BaseFilteringFormRendererComponent as Éµa, GroupFilteringFormRendererComponent as Éµb, StatusCellRendererComponent as Éµc, NameCellRendererComponent as Éµd, ModelCellRendererComponent as Éµe, SerialNumberCellRendererComponent as Éµf, GroupCellRendererComponent as Éµg, RegistrationDateCellRendererComponent as Éµh, AlarmsCellRendererComponent as Éµi };
//# sourceMappingURL=c8y-ngx-components-device-grid.js.map
