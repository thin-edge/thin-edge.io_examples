(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@c8y/client'), require('@ngx-translate/core'), require('lodash-es'), require('@c8y/ngx-components'), require('@angular/upgrade/static'), require('@c8y/ngx-components/assets-navigator')) :
    typeof define === 'function' && define.amd ? define('@c8y/ngx-components/device-grid', ['exports', '@angular/core', '@c8y/client', '@ngx-translate/core', 'lodash-es', '@c8y/ngx-components', '@angular/upgrade/static', '@c8y/ngx-components/assets-navigator'], factory) :
    (global = global || self, factory((global.c8y = global.c8y || {}, global.c8y['ngx-components'] = global.c8y['ngx-components'] || {}, global.c8y['ngx-components']['device-grid'] = {}), global.ng.core, global.client, global.core$1, global.lodashEs, global.c8y['ngx-components'], global.ng.upgrade.static, global.c8y['ngx-components']['assets-navigator']));
}(this, (function (exports, core, client, core$1, lodashEs, ngxComponents, _static, assetsNavigator) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    // TODO: MTM-31785: find replacement for schema-form ng1 library
    var SchemaFormComponent = /** @class */ (function (_super) {
        __extends(SchemaFormComponent, _super);
        function SchemaFormComponent(elementRef, injector) {
            return _super.call(this, 'c8ySchemaForm', elementRef, injector) || this;
        }
        SchemaFormComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Injector }
        ]; };
        __decorate([
            core.Input()
        ], SchemaFormComponent.prototype, "schema", void 0);
        __decorate([
            core.Input()
        ], SchemaFormComponent.prototype, "model", void 0);
        __decorate([
            core.Input('form')
        ], SchemaFormComponent.prototype, "inputForm", void 0);
        __decorate([
            core.Input('options')
        ], SchemaFormComponent.prototype, "inputOptions", void 0);
        SchemaFormComponent = __decorate([
            core.Directive({
                selector: 'c8y-schema-form'
            })
        ], SchemaFormComponent);
        return SchemaFormComponent;
    }(_static.UpgradeComponent));

    var BaseFilteringFormRendererComponent = /** @class */ (function () {
        function BaseFilteringFormRendererComponent(context) {
            this.context = context;
        }
        BaseFilteringFormRendererComponent.prototype.ngOnInit = function () {
            var column = this.context.property;
            this.schema = lodashEs.cloneDeep(column.filteringConfig.schema);
            this.form = lodashEs.cloneDeep(column.filteringConfig.form);
            this.model = lodashEs.cloneDeep(column.externalFilterQuery || {});
            this.options = { formDefaults: { ngModelOptions: { debounce: 100 } } };
        };
        BaseFilteringFormRendererComponent.prototype.canApply = function () {
            return lodashEs.get(this.schemaFormComponent, '$componentScope.vm.ngForm.$invalid');
        };
        BaseFilteringFormRendererComponent.prototype.applyFilter = function () {
            this.context.applyFilter({
                externalFilterQuery: this.model
            });
        };
        BaseFilteringFormRendererComponent.prototype.resetFilter = function () {
            this.context.resetFilter();
        };
        BaseFilteringFormRendererComponent.ctorParameters = function () { return [
            { type: ngxComponents.FilteringFormRendererContext }
        ]; };
        __decorate([
            core.ViewChild(core.forwardRef(function () { return SchemaFormComponent; }), { static: false })
        ], BaseFilteringFormRendererComponent.prototype, "schemaFormComponent", void 0);
        BaseFilteringFormRendererComponent = __decorate([
            core.Component({
                template: "<c8y-schema-form\n  [schema]=\"schema\"\n  [form]=\"form\"\n  [model]=\"model\"\n  [options]=\"options\"\n></c8y-schema-form>\n<div class=\"data-grid__dropdown__footer d-flex separator-top\">\n  <button\n    class=\"btn btn-default btn-sm m-r-8 flex-grow\"\n    (click)=\"resetFilter()\"\n    title=\"{{ 'Reset' | translate }}\"\n    translate\n  >\n    Reset\n  </button>\n\n  <button\n    class=\"btn btn-primary btn-sm flex-grow\"\n    (click)=\"applyFilter()\"\n    [disabled]=\"canApply()\"\n    title=\"{{ 'Apply' | translate }}\"\n    translate\n  >\n    Apply\n  </button>\n</div>\n"
            })
        ], BaseFilteringFormRendererComponent);
        return BaseFilteringFormRendererComponent;
    }());

    var BaseDeviceGridColumn = /** @class */ (function () {
        function BaseDeviceGridColumn(config) {
            if (config === void 0) { config = {}; }
            this.filteringFormRendererComponent = BaseFilteringFormRendererComponent;
            Object.assign(this, config);
        }
        return BaseDeviceGridColumn;
    }());

    var AlarmsCellRendererComponent = /** @class */ (function () {
        function AlarmsCellRendererComponent(context, deviceGridService) {
            this.context = context;
            this.deviceGridService = deviceGridService;
        }
        AlarmsCellRendererComponent.ctorParameters = function () { return [
            { type: ngxComponents.CellRendererContext },
            { type: DeviceGridService, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return DeviceGridService; }),] }] }
        ]; };
        AlarmsCellRendererComponent = __decorate([
            core.Component({
                template: "<a class=\"listLink\"\n  [href]=\"deviceGridService.getAlarmsHref(context.item)\" \n>\n  <small class=\"status critical text-nowrap\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.critical\"\n  >\n    {{ context.item.c8y_ActiveAlarmsStatus?.critical }}\n    <i [c8yIcon]=\"'warning'\"></i>\n  </small>\n  <small class=\"status major text-nowrap\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.major\"\n  >\n    {{ context.item.c8y_ActiveAlarmsStatus?.major }}\n    <i [c8yIcon]=\"'exclamation-circle'\"></i>\n  </small>\n  <small class=\"status minor text-nowrap\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.minor\"\n  >\n    {{ context.item.c8y_ActiveAlarmsStatus?.minor }}\n    <i [c8yIcon]=\"'exclamation-circle'\"></i>\n  </small>\n  <small class=\"status warning text-nowrap\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.warning\"\n  >\n    {{ context.item.c8y_ActiveAlarmsStatus?.warning }}\n    <i [c8yIcon]=\"'circle'\"></i>\n  </small>\n</a>\n"
            }),
            __param(1, core.Inject(core.forwardRef(function () { return DeviceGridService; })))
        ], AlarmsCellRendererComponent);
        return AlarmsCellRendererComponent;
    }());

    var AlarmsDeviceGridColumn = /** @class */ (function (_super) {
        __extends(AlarmsDeviceGridColumn, _super);
        function AlarmsDeviceGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            _this.name = 'alarms';
            _this.header = ngxComponents.gettext('Alarms');
            _this.cellRendererComponent = AlarmsCellRendererComponent;
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        critical: {
                            type: 'boolean'
                        },
                        major: {
                            type: 'boolean'
                        },
                        minor: {
                            type: 'boolean'
                        },
                        warning: {
                            type: 'boolean'
                        },
                        none: {
                            type: 'boolean'
                        }
                    }
                },
                form: [
                    {
                        type: 'template',
                        template: "<label><span translate>" + ngxComponents.gettext('Show devices with active') + "</span>:</label>"
                    },
                    {
                        key: 'critical',
                        title: ngxComponents.gettext('Critical alarms')
                    },
                    {
                        key: 'major',
                        title: ngxComponents.gettext('Major alarms')
                    },
                    {
                        key: 'minor',
                        title: ngxComponents.gettext('Minor alarms')
                    },
                    {
                        key: 'warning',
                        title: ngxComponents.gettext('Warnings')
                    },
                    {
                        key: 'none',
                        title: ngxComponents.gettext('No alarms')
                    }
                ],
                getFilter: function (model) {
                    var filter = {};
                    var ors = [];
                    if (model.critical) {
                        ors.push({ 'c8y_ActiveAlarmsStatus.critical': { __gt: 0 } });
                    }
                    if (model.major) {
                        ors.push({ 'c8y_ActiveAlarmsStatus.major': { __gt: 0 } });
                    }
                    if (model.minor) {
                        ors.push({ 'c8y_ActiveAlarmsStatus.minor': { __gt: 0 } });
                    }
                    if (model.warning) {
                        ors.push({ 'c8y_ActiveAlarmsStatus.warning': { __gt: 0 } });
                    }
                    if (model.none) {
                        ors.push({ __not: { __has: 'c8y_ActiveAlarmsStatus' } });
                        ors.push({
                            __and: lodashEs.map(['critical', 'major', 'minor', 'warning'], function (sev) {
                                var zero = {};
                                var has = { __not: { __has: undefined } };
                                var key = "c8y_ActiveAlarmsStatus." + sev;
                                zero[key] = 0;
                                has.__not.__has = key;
                                return { __or: [zero, has] };
                            })
                        });
                    }
                    if (ors.length) {
                        filter.__or = ors;
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = {
                pathSortingConfigs: [
                    { path: 'c8y_ActiveAlarmsStatus.critical' },
                    { path: 'c8y_ActiveAlarmsStatus.major' },
                    { path: 'c8y_ActiveAlarmsStatus.minor' },
                    { path: 'c8y_ActiveAlarmsStatus.warning' }
                ]
            };
            return _this;
        }
        return AlarmsDeviceGridColumn;
    }(BaseDeviceGridColumn));

    var GroupCellRendererComponent = /** @class */ (function () {
        function GroupCellRendererComponent(context, deviceGridService) {
            this.context = context;
            this.deviceGridService = deviceGridService;
        }
        GroupCellRendererComponent.ctorParameters = function () { return [
            { type: ngxComponents.CellRendererContext },
            { type: DeviceGridService, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return DeviceGridService; }),] }] }
        ]; };
        GroupCellRendererComponent = __decorate([
            core.Component({
                template: "<span\n  title=\"{{\n    deviceGridService.getParentsNames(\n      context.item,\n      context.property.externalFilterQuery?.deviceGroupId\n    )\n  }}\"\n  class=\"text-truncate\"\n>\n  {{\n    deviceGridService.getParentsNames(\n      context.item,\n      context.property.externalFilterQuery?.deviceGroupId\n    )\n  }}\n</span>\n"
            }),
            __param(1, core.Inject(core.forwardRef(function () { return DeviceGridService; })))
        ], GroupCellRendererComponent);
        return GroupCellRendererComponent;
    }());

    var GroupFilteringFormRendererComponent = /** @class */ (function () {
        function GroupFilteringFormRendererComponent(context) {
            this.context = context;
            this.preselected = [];
        }
        GroupFilteringFormRendererComponent.prototype.ngOnInit = function () {
            var column = this.context.property;
            this.model = lodashEs.cloneDeep(column.externalFilterQuery || {});
            this.preselected = this.model.selectedNodes || [];
        };
        GroupFilteringFormRendererComponent.prototype.applyFilter = function () {
            this.context.applyFilter({
                externalFilterQuery: this.model
            });
        };
        GroupFilteringFormRendererComponent.prototype.resetFilter = function () {
            this.context.resetFilter();
        };
        GroupFilteringFormRendererComponent.prototype.selectionChanged = function (nodes) {
            this.model.selectedNodes = nodes;
        };
        GroupFilteringFormRendererComponent.ctorParameters = function () { return [
            { type: ngxComponents.FilteringFormRendererContext }
        ]; };
        GroupFilteringFormRendererComponent = __decorate([
            core.Component({
                template: "<c8y-asset-selector\n  [selected]=\"preselected\"\n  (onChange)=\"selectionChanged($event)\"\n></c8y-asset-selector>\n\n<div class=\"data-grid__dropdown__footer d-flex separator-top\">\n  <button\n    class=\"btn btn-default btn-sm m-r-8 flex-grow\"\n    (click)=\"resetFilter()\"\n    title=\"{{ 'Reset' | translate }}\"\n    translate\n  >\n    Reset\n  </button>\n\n  <button\n    class=\"btn btn-primary btn-sm flex-grow\"\n    (click)=\"applyFilter()\"\n    title=\"{{ 'Apply' | translate }}\"\n    translate\n  >\n    Apply\n  </button>\n</div>\n"
            })
        ], GroupFilteringFormRendererComponent);
        return GroupFilteringFormRendererComponent;
    }());

    var GroupDeviceGridColumn = /** @class */ (function (_super) {
        __extends(GroupDeviceGridColumn, _super);
        function GroupDeviceGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            _this.name = 'group';
            _this.header = ngxComponents.gettext('Group');
            _this.cellRendererComponent = GroupCellRendererComponent;
            _this.filteringFormRendererComponent = GroupFilteringFormRendererComponent;
            _this.filterable = true;
            _this.filteringConfig = {
                getFilter: function (model) {
                    var filter = {};
                    if (model.selectedNodes) {
                        filter.__or = model.selectedNodes.map(function (mo) {
                            if (mo.c8y_DeviceQueryString) {
                                return { __useFilterQueryString: mo.c8y_DeviceQueryString };
                            }
                            return { __bygroupid: mo.id };
                        });
                    }
                    return filter;
                }
            };
            _this.sortable = false;
            return _this;
        }
        return GroupDeviceGridColumn;
    }(BaseDeviceGridColumn));

    var ImeiDeviceGridColumn = /** @class */ (function (_super) {
        __extends(ImeiDeviceGridColumn, _super);
        function ImeiDeviceGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            var self = _this;
            _this.path = 'c8y_Mobile.imei';
            _this.name = 'imei';
            _this.header = ngxComponents.gettext('IMEI');
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        imeis: {
                            type: 'array',
                            items: {
                                type: 'string'
                            }
                        }
                    }
                },
                form: [
                    {
                        key: 'imeis',
                        title: ngxComponents.gettext('Show devices with IMEI'),
                        add: ngxComponents.gettext('Or'),
                        items: [
                            {
                                key: 'imeis[]',
                                notitle: true,
                                placeholder: ngxComponents.gettext('e.g. 46543432321, you can use an asterisk (*) as wildcard character')
                            }
                        ]
                    }
                ],
                getFilter: function (model) {
                    var filter = {};
                    if (model.imeis.length) {
                        filter[self.path] = { __in: model.imeis };
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = {
                pathSortingConfigs: [{ path: _this.path }]
            };
            return _this;
        }
        return ImeiDeviceGridColumn;
    }(BaseDeviceGridColumn));

    var ModelCellRendererComponent = /** @class */ (function () {
        function ModelCellRendererComponent(context, deviceGridService) {
            this.context = context;
            this.deviceGridService = deviceGridService;
        }
        ModelCellRendererComponent.ctorParameters = function () { return [
            { type: ngxComponents.CellRendererContext },
            { type: DeviceGridService, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return DeviceGridService; }),] }] }
        ]; };
        ModelCellRendererComponent = __decorate([
            core.Component({
                template: "\n    {{ deviceGridService.getModel(context.item) }}\n  "
            }),
            __param(1, core.Inject(core.forwardRef(function () { return DeviceGridService; })))
        ], ModelCellRendererComponent);
        return ModelCellRendererComponent;
    }());

    var ModelDeviceGridColumn = /** @class */ (function (_super) {
        __extends(ModelDeviceGridColumn, _super);
        function ModelDeviceGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            var hardwareModelPath = 'c8y_Hardware.model';
            var vendingModelPath = 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo.model';
            _this.name = 'model';
            _this.header = ngxComponents.gettext('Model');
            _this.cellRendererComponent = ModelCellRendererComponent;
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        models: {
                            type: 'array',
                            items: {
                                type: 'string'
                            }
                        }
                    }
                },
                form: [
                    {
                        key: 'models',
                        title: ngxComponents.gettext('Show devices with model'),
                        add: ngxComponents.gettext('Or'),
                        items: [
                            {
                                key: 'models[]',
                                notitle: true,
                                placeholder: ngxComponents.gettext('e.g. ModelName, you can use an asterisk (*) as wildcard character')
                            }
                        ]
                    }
                ],
                getFilter: function (model) {
                    var _a;
                    var filter = {};
                    if (model.models.length) {
                        filter.__or = (_a = {},
                            _a[hardwareModelPath] = { __in: model.models },
                            _a[vendingModelPath] = { __in: model.models },
                            _a);
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = {
                pathSortingConfigs: [{ path: hardwareModelPath }, { path: vendingModelPath }]
            };
            return _this;
        }
        return ModelDeviceGridColumn;
    }(BaseDeviceGridColumn));

    var NameCellRendererComponent = /** @class */ (function () {
        function NameCellRendererComponent(context, deviceGridService) {
            this.context = context;
            this.deviceGridService = deviceGridService;
        }
        NameCellRendererComponent.ctorParameters = function () { return [
            { type: ngxComponents.CellRendererContext },
            { type: DeviceGridService, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return DeviceGridService; }),] }] }
        ]; };
        NameCellRendererComponent = __decorate([
            core.Component({
                template: "\n    <a\n      [href]=\"deviceGridService.getHref(context.item)\"\n      title=\"{{ deviceGridService.getProperName(context.item) }}\"\n      class=\"interact\"\n    >\n      {{ deviceGridService.getProperName(context.item) }}\n    </a>\n  "
            }),
            __param(1, core.Inject(core.forwardRef(function () { return DeviceGridService; })))
        ], NameCellRendererComponent);
        return NameCellRendererComponent;
    }());

    var NameDeviceGridColumn = /** @class */ (function (_super) {
        __extends(NameDeviceGridColumn, _super);
        function NameDeviceGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            _this.name = 'name';
            _this.path = 'name';
            _this.header = ngxComponents.gettext('Name');
            _this.cellCSSClassName = "data-record-header" /* Header */;
            _this.cellRendererComponent = NameCellRendererComponent;
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        names: {
                            type: 'array',
                            items: {
                                type: 'string'
                            }
                        }
                    }
                },
                form: [
                    {
                        key: 'names',
                        title: ngxComponents.gettext('Show devices with name'),
                        add: ngxComponents.gettext('Or'),
                        items: [
                            {
                                key: 'names[]',
                                notitle: true,
                                placeholder: ngxComponents.gettext('e.g. My Device, you can use an asterisk (*) as wildcard character')
                            }
                        ]
                    }
                ],
                getFilter: function (model) {
                    var filter = {};
                    if (model.names.length) {
                        filter.name = { __in: model.names };
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = {
                pathSortingConfigs: [{ path: _this.path }]
            };
            return _this;
        }
        return NameDeviceGridColumn;
    }(BaseDeviceGridColumn));

    var RegistrationDateCellRendererComponent = /** @class */ (function () {
        function RegistrationDateCellRendererComponent(context) {
            this.context = context;
        }
        RegistrationDateCellRendererComponent.ctorParameters = function () { return [
            { type: ngxComponents.CellRendererContext }
        ]; };
        RegistrationDateCellRendererComponent = __decorate([
            core.Component({
                template: "\n    {{ context.value | c8yDate }}\n  "
            })
        ], RegistrationDateCellRendererComponent);
        return RegistrationDateCellRendererComponent;
    }());

    var RegistrationDateDeviceGridColumn = /** @class */ (function (_super) {
        __extends(RegistrationDateDeviceGridColumn, _super);
        function RegistrationDateDeviceGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            var self = _this;
            _this.path = 'creationTime';
            _this.name = 'registrationDate';
            _this.header = ngxComponents.gettext('Registration date');
            _this.cellRendererComponent = RegistrationDateCellRendererComponent;
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        registrationDate: {
                            type: 'object',
                            properties: {
                                after: {
                                    type: 'string',
                                    format: 'datetime'
                                },
                                before: {
                                    type: 'string',
                                    format: 'datetime'
                                }
                            }
                        }
                    }
                },
                form: [
                    {
                        key: 'registrationDate.after',
                        title: ngxComponents.gettext('Show devices registered after'),
                        maxDateKey: 'registrationDate.before'
                    },
                    {
                        key: 'registrationDate.before',
                        title: ngxComponents.gettext('And before`date`'),
                        minDateKey: 'registrationDate.after'
                    }
                ],
                getFilter: function (model) {
                    var _a, _b;
                    var filter = {};
                    var dates = model && model.registrationDate;
                    if (dates && (dates.after || dates.before)) {
                        filter.__and = [];
                        if (dates.after) {
                            var after = self.formatDate(dates.after);
                            filter.__and.push({
                                __or: (_a = {},
                                    _a[self.path] = { __gt: after },
                                    _a[self.path + ".date"] = { __gt: after },
                                    _a)
                            });
                        }
                        if (dates.before) {
                            var before = self.formatDate(dates.before);
                            filter.__and.push({
                                __or: (_b = {},
                                    _b[self.path] = { __lt: before },
                                    _b[self.path + ".date"] = { __lt: before },
                                    _b)
                            });
                        }
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = {
                pathSortingConfigs: [{ path: _this.path + ".date" }, { path: _this.path }]
            };
            return _this;
        }
        RegistrationDateDeviceGridColumn.prototype.formatDate = function (dateToFormat) {
            return new Date(dateToFormat).toISOString();
        };
        return RegistrationDateDeviceGridColumn;
    }(BaseDeviceGridColumn));

    var SerialNumberCellRendererComponent = /** @class */ (function () {
        function SerialNumberCellRendererComponent(context, deviceGridService) {
            this.context = context;
            this.deviceGridService = deviceGridService;
        }
        SerialNumberCellRendererComponent.ctorParameters = function () { return [
            { type: ngxComponents.CellRendererContext },
            { type: DeviceGridService, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return DeviceGridService; }),] }] }
        ]; };
        SerialNumberCellRendererComponent = __decorate([
            core.Component({
                template: "\n    {{ deviceGridService.getSerialNumber(context.item) }}\n  "
            }),
            __param(1, core.Inject(core.forwardRef(function () { return DeviceGridService; })))
        ], SerialNumberCellRendererComponent);
        return SerialNumberCellRendererComponent;
    }());

    var SerialNumberDeviceGridColumn = /** @class */ (function (_super) {
        __extends(SerialNumberDeviceGridColumn, _super);
        function SerialNumberDeviceGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            var hardwareSerialNumberPath = 'c8y_Hardware.serialNumber';
            var vendingSerialNumberPath = 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo.serial';
            _this.name = 'serialNumber';
            _this.header = ngxComponents.gettext('Serial number');
            _this.cellRendererComponent = SerialNumberCellRendererComponent;
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        serialNumbers: {
                            type: 'array',
                            items: {
                                type: 'string'
                            }
                        }
                    }
                },
                form: [
                    {
                        key: 'serialNumbers',
                        title: ngxComponents.gettext('Show devices with serial number'),
                        add: ngxComponents.gettext('Or'),
                        items: [
                            {
                                key: 'serialNumbers[]',
                                notitle: true,
                                placeholder: ngxComponents.gettext('e.g. 54321-123, you can use an asterisk (*) as wildcard character')
                            }
                        ]
                    }
                ],
                getFilter: function (model) {
                    var _a;
                    var filter = {};
                    if (model.serialNumbers.length) {
                        filter.__or = (_a = {},
                            _a[hardwareSerialNumberPath] = { __in: model.serialNumbers },
                            _a[vendingSerialNumberPath] = { __in: model.serialNumbers },
                            _a);
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = {
                pathSortingConfigs: [{ path: hardwareSerialNumberPath }, { path: vendingSerialNumberPath }]
            };
            return _this;
        }
        return SerialNumberDeviceGridColumn;
    }(BaseDeviceGridColumn));

    var StatusCellRendererComponent = /** @class */ (function () {
        function StatusCellRendererComponent(context) {
            this.context = context;
        }
        StatusCellRendererComponent.ctorParameters = function () { return [
            { type: ngxComponents.CellRendererContext }
        ]; };
        StatusCellRendererComponent = __decorate([
            core.Component({
                template: "\n    <device-status [mo]=\"context.item\"></device-status>\n  "
            })
        ], StatusCellRendererComponent);
        return StatusCellRendererComponent;
    }());

    var StatusDeviceGridColumn = /** @class */ (function (_super) {
        __extends(StatusDeviceGridColumn, _super);
        function StatusDeviceGridColumn() {
            var _a, _b, _c, _d, _e, _f, _g;
            var _this = _super.call(this) || this;
            var responseIntervalPath = 'c8y_RequiredAvailability.responseInterval';
            var responseIntervalLessThanOrEqualTo0 = (_a = {}, _a[responseIntervalPath] = { __le: 0 }, _a);
            var responseIntervalNotDefined = { __not: { __has: responseIntervalPath } };
            var availabilityStatusPath = 'c8y_Availability.status';
            var availabilityStatusAvailable = (_b = {}, _b[availabilityStatusPath] = ngxComponents.SendStatus.AVAILABLE, _b);
            var availabilityStatusUnavailable = (_c = {}, _c[availabilityStatusPath] = ngxComponents.SendStatus.UNAVAILABLE, _c);
            var availabilityStatusMaintenance = (_d = {}, _d[availabilityStatusPath] = ngxComponents.SendStatus.MAINTENANCE, _d);
            var availabilityStatusNotDefined = { __not: { __has: availabilityStatusPath } };
            var connectionStatusPath = 'c8y_Connection.status';
            var connectionStatusConnected = (_e = {}, _e[connectionStatusPath] = ngxComponents.PushStatus.CONNECTED, _e);
            var connectionStatusDisconnected = (_f = {}, _f[connectionStatusPath] = ngxComponents.PushStatus.DISCONNECTED, _f);
            var connectionStatusMaintenance = (_g = {}, _g[connectionStatusPath] = ngxComponents.PushStatus.MAINTENANCE, _g);
            var deviceUnderMaintenance = {
                __or: [
                    responseIntervalLessThanOrEqualTo0,
                    availabilityStatusMaintenance,
                    connectionStatusMaintenance
                ]
            };
            var deviceNotUnderMaintenance = {
                // using __and of __nots because backend does not support __not with __ors
                __and: [
                    { __not: responseIntervalLessThanOrEqualTo0 },
                    { __not: availabilityStatusMaintenance },
                    { __not: connectionStatusMaintenance }
                ]
            };
            _this.name = 'status';
            _this.header = ngxComponents.gettext('Status');
            _this.dataType = "icon" /* Icon */;
            _this.cellRendererComponent = StatusCellRendererComponent;
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        sendOnline: {
                            type: 'boolean'
                        },
                        sendOffline: {
                            type: 'boolean'
                        },
                        sendUnknown: {
                            type: 'boolean'
                        },
                        sendNotMonitored: {
                            type: 'boolean'
                        },
                        pushOnline: {
                            type: 'boolean'
                        },
                        pushOffline: {
                            type: 'boolean'
                        },
                        pushNotMonitored: {
                            type: 'boolean'
                        },
                        maintenance: {
                            type: 'boolean'
                        }
                    }
                },
                form: [
                    {
                        type: 'template',
                        template: "<label><span translate>" + ngxComponents.gettext('Show devices with send status') + "</span>:</label>"
                    },
                    {
                        key: 'sendOnline',
                        title: ngxComponents.gettext('Online')
                    },
                    {
                        key: 'sendOffline',
                        title: ngxComponents.gettext('Offline')
                    },
                    {
                        key: 'sendUnknown',
                        title: ngxComponents.gettext('Unknown')
                    },
                    {
                        key: 'sendNotMonitored',
                        title: ngxComponents.gettext('Not monitored')
                    },
                    {
                        type: 'template',
                        template: "<label><span translate>" + ngxComponents.gettext('Show devices with push status') + "</span>:</label>"
                    },
                    {
                        key: 'pushOnline',
                        title: ngxComponents.gettext('Online')
                    },
                    {
                        key: 'pushOffline',
                        title: ngxComponents.gettext('Offline')
                    },
                    {
                        key: 'pushNotMonitored',
                        title: ngxComponents.gettext('Not monitored')
                    },
                    {
                        type: 'template',
                        template: "<label><span translate>" + ngxComponents.gettext('Show devices with maintenance status') + "</span>:</label>"
                    },
                    {
                        key: 'maintenance',
                        title: ngxComponents.gettext('Device is under maintenance')
                    }
                ],
                getFilter: function (model) {
                    var filter = {};
                    var ors = [];
                    if (model) {
                        if (model.sendOnline) {
                            ors.push({
                                __and: [deviceNotUnderMaintenance, availabilityStatusAvailable]
                            });
                        }
                        if (model.sendOffline) {
                            ors.push({
                                __and: [deviceNotUnderMaintenance, availabilityStatusUnavailable]
                            });
                        }
                        if (model.sendUnknown) {
                            ors.push({
                                __and: [deviceNotUnderMaintenance, availabilityStatusNotDefined]
                            });
                        }
                        if (model.sendNotMonitored || model.pushNotMonitored) {
                            ors.push(responseIntervalNotDefined);
                        }
                        if (model.pushOnline) {
                            ors.push({
                                __and: [deviceNotUnderMaintenance, connectionStatusConnected]
                            });
                        }
                        if (model.pushOffline) {
                            ors.push({
                                __and: [deviceNotUnderMaintenance, connectionStatusDisconnected]
                            });
                        }
                        if (model.maintenance) {
                            ors.push(deviceUnderMaintenance);
                        }
                        if (ors.length) {
                            filter.__or = ors;
                        }
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = {
                pathSortingConfigs: [{ path: availabilityStatusPath }]
            };
            return _this;
        }
        return StatusDeviceGridColumn;
    }(BaseDeviceGridColumn));

    var SystemIdDeviceGridColumn = /** @class */ (function (_super) {
        __extends(SystemIdDeviceGridColumn, _super);
        function SystemIdDeviceGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            var self = _this;
            _this.path = 'id';
            _this.name = 'systemId';
            _this.header = ngxComponents.gettext('System ID');
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        ids: {
                            type: 'array',
                            items: {
                                type: 'string'
                            }
                        }
                    }
                },
                form: [
                    {
                        key: 'ids',
                        title: ngxComponents.gettext('Show devices with system ID'),
                        add: ngxComponents.gettext('Or'),
                        items: [
                            {
                                key: 'ids[]',
                                notitle: true,
                                placeholder: ngxComponents.gettext('e.g. 10300, you can use an asterisk (*) as wildcard character')
                            }
                        ]
                    }
                ],
                getFilter: function (model) {
                    var filter = {};
                    if (model.ids.length) {
                        filter[self.path] = { __in: model.ids };
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = {
                pathSortingConfigs: [{ path: _this.path }]
            };
            return _this;
        }
        return SystemIdDeviceGridColumn;
    }(BaseDeviceGridColumn));

    var DeviceGridService = /** @class */ (function () {
        function DeviceGridService(inventoryService, translateService) {
            this.inventoryService = inventoryService;
            this.translateService = translateService;
            this.GRID_CONFIG_DEFAULT_STORAGE_KEY = 'device-grid-config';
            this.DEFAULT_PAGE_SIZE = 20;
            this.queriesUtil = new client.QueriesUtil();
        }
        DeviceGridService.prototype.getDefaultColumns = function () {
            var defaultColumns = [
                new StatusDeviceGridColumn(),
                new NameDeviceGridColumn(),
                new ModelDeviceGridColumn(),
                new SerialNumberDeviceGridColumn(),
                new GroupDeviceGridColumn(),
                new RegistrationDateDeviceGridColumn(),
                new SystemIdDeviceGridColumn(),
                new ImeiDeviceGridColumn(),
                new AlarmsDeviceGridColumn()
            ];
            return defaultColumns;
        };
        DeviceGridService.prototype.getDefaultPagination = function () {
            return {
                pageSize: 10,
                currentPage: 1
            };
        };
        DeviceGridService.prototype.getInfiniteScrollPagination = function () {
            return {
                pageSize: 50,
                currentPage: 1
            };
        };
        DeviceGridService.prototype.getDefaultActionControls = function () {
            var _this = this;
            return [
                {
                    type: "DELETE" /* Delete */,
                    callback: function (item) { return _this.delete(item); }
                }
            ];
        };
        DeviceGridService.prototype.getDefaultBulkActionControls = function () {
            return [];
        };
        DeviceGridService.prototype.getProperName = function (device) {
            var id = device.id, name = device.name;
            return name ? name : this.translateService.instant('Device {{id}}', { id: id });
        };
        DeviceGridService.prototype.getModel = function (device) {
            var hardware = this.getHardware(device);
            return hardware && hardware.model;
        };
        DeviceGridService.prototype.getSerialNumber = function (device) {
            var hardware = this.getHardware(device);
            var serialPropertyName = this.isVendme(device) ? 'serial' : 'serialNumber';
            return hardware && hardware[serialPropertyName];
        };
        DeviceGridService.prototype.getParentsNames = function (device, featuredParentId) {
            var assetParentsReferences = device.assetParents.references;
            var assetParents = lodashEs.map(assetParentsReferences, 'managedObject');
            var sortedByName = lodashEs.sortBy(assetParents, ['name']);
            var featuredItems = lodashEs.remove(sortedByName, { id: featuredParentId });
            var items = featuredItems.concat(sortedByName);
            var names = lodashEs.map(items, 'name');
            return names.join(', ');
        };
        DeviceGridService.prototype.getHref = function (groupOrDevice, prefix) {
            if (prefix === void 0) { prefix = '#/'; }
            if (groupOrDevice.c8y_IsDeviceGroup || groupOrDevice.c8y_IsDynamicGroup) {
                return prefix + "group/" + groupOrDevice.id;
            }
            return prefix + "device/" + groupOrDevice.id;
        };
        DeviceGridService.prototype.getAlarmsHref = function (device) {
            return this.getHref(device) + "/alarms";
        };
        DeviceGridService.prototype.getUserConfiguredColumns = function (columns) {
            var config = this.getConfig();
            if (config.columns.length > 0) {
                var reOrderedColumns_1 = [];
                var noConfigColumns = [];
                try {
                    noConfigColumns = columns.filter(function (col) { return !config.columns.includes(col); });
                    config.columns.forEach(function (_a) {
                        var visible = _a.visible, name = _a.name, sortOrder = _a.sortOrder;
                        var columnToReorder = columns.find(function (col) { return col.name === name; });
                        if (columnToReorder) {
                            columnToReorder.visible = visible;
                            columnToReorder.sortOrder = sortOrder;
                            reOrderedColumns_1.push(columnToReorder);
                        }
                    });
                }
                catch (ex) {
                    this.clearConfig();
                }
                return __spread(reOrderedColumns_1, noConfigColumns);
            }
            return columns;
        };
        DeviceGridService.prototype.delete = function (device) {
            console.log('should delete', device);
        };
        DeviceGridService.prototype.getData = function (columns, pagination, query, withChildren) {
            if (query === void 0) { query = {}; }
            if (withChildren === void 0) { withChildren = false; }
            return __awaiter(this, void 0, void 0, function () {
                var filters;
                return __generator(this, function (_a) {
                    filters = __assign({}, this.getDevicesFilters(columns, pagination, query), { withParents: true, withChildren: withChildren });
                    return [2 /*return*/, this.inventoryService.list(filters)];
                });
            });
        };
        DeviceGridService.prototype.getCount = function (columns, pagination, query) {
            if (query === void 0) { query = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var filters;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            filters = __assign({}, this.getDevicesFilters(columns, pagination, query), { pageSize: 1, currentPage: 1 });
                            return [4 /*yield*/, this.inventoryService.list(filters)];
                        case 1: return [2 /*return*/, (_a.sent()).paging.totalPages];
                    }
                });
            });
        };
        DeviceGridService.prototype.getTotal = function (query) {
            if (query === void 0) { query = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var filters;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            filters = {
                                q: this.queriesUtil.buildQuery(query),
                                pageSize: 1,
                                withTotalPages: true
                            };
                            return [4 /*yield*/, this.inventoryService.list(filters)];
                        case 1: return [2 /*return*/, (_a.sent()).paging.totalPages];
                    }
                });
            });
        };
        DeviceGridService.prototype.getDeviceQueryString = function (columns, query) {
            var fullQuery = this.getQueryObj(columns);
            fullQuery = this.queriesUtil.addAndFilter(fullQuery, query);
            return this.queriesUtil.buildQuery(fullQuery);
        };
        DeviceGridService.prototype.getQueryObj = function (columns, defaultFilter) {
            var _this = this;
            if (defaultFilter === void 0) { defaultFilter = {}; }
            return lodashEs.transform(columns, function (query, column) { return _this.extendQueryByColumn(query, column); }, __assign({ __filter: {}, __orderby: [] }, defaultFilter));
        };
        DeviceGridService.prototype.getConfig = function (key) {
            if (key === void 0) { key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY; }
            var config = JSON.parse(localStorage.getItem(key));
            if (config === null) {
                return { columns: [], pagination: { pageSize: this.DEFAULT_PAGE_SIZE, currentPage: 1 } };
            }
            return config;
        };
        DeviceGridService.prototype.saveConfig = function (config, key) {
            if (key === void 0) { key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY; }
            localStorage.setItem(key, JSON.stringify(config));
        };
        DeviceGridService.prototype.clearConfig = function (key) {
            if (key === void 0) { key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY; }
            localStorage.removeItem(key);
        };
        DeviceGridService.prototype.getHardware = function (device) {
            var hardwarePropertyName = this.isVendme(device)
                ? 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo'
                : 'c8y_Hardware';
            return device && device[hardwarePropertyName];
        };
        DeviceGridService.prototype.isVendme = function (device) {
            return device.type === 'com_nsn_startups_vendme_VendingMachine';
        };
        DeviceGridService.prototype.getDevicesFilters = function (columns, pagination, query) {
            return {
                q: this.getDeviceQueryString(columns, query),
                pageSize: pagination.pageSize,
                currentPage: pagination.currentPage,
                withChildren: false,
                withTotalPages: true
            };
        };
        DeviceGridService.prototype.extendQueryByColumn = function (query, column) {
            if (column.filterable && column.externalFilterQuery) {
                var getFilter = column.filteringConfig.getFilter || lodashEs.identity;
                var queryObj = getFilter(column.externalFilterQuery);
                if (queryObj.__or) {
                    query.__filter.__and = query.__filter.__and || [];
                    query.__filter.__and.push(queryObj);
                }
                else if (queryObj.__and && lodashEs.get(query, '__filter.__and')) {
                    queryObj.__and.map(function (obj) { return query.__filter.__and.push(obj); });
                }
                else {
                    lodashEs.assign(query.__filter, queryObj);
                }
            }
            if (column.sortable && column.sortOrder) {
                var cs_1 = {};
                lodashEs.forEach(column.sortingConfig.pathSortingConfigs, function (pathSortingConfig) {
                    cs_1[pathSortingConfig.path] =
                        (column.sortOrder === 'asc' ? 1 : -1) * (pathSortingConfig.sortOrderModifier || 1);
                });
                query.__orderby.push(cs_1);
            }
            return query;
        };
        DeviceGridService.ctorParameters = function () { return [
            { type: client.InventoryService },
            { type: core$1.TranslateService }
        ]; };
        DeviceGridService = __decorate([
            core.Injectable()
        ], DeviceGridService);
        return DeviceGridService;
    }());

    var DeviceGridComponent = /** @class */ (function () {
        function DeviceGridComponent(deviceGridService) {
            this.deviceGridService = deviceGridService;
            this.title = ngxComponents.gettext('Devices');
            this.loadMoreItemsLabel = ngxComponents.gettext('Load more devices');
            this.loadingItemsLabel = ngxComponents.gettext('Loading devices');
            this.selectable = false;
            this.baseQuery = {};
            this.showChildDevices = {};
            this.onColumnsChange = new core.EventEmitter();
            this.onDeviceQueryStringChange = new core.EventEmitter();
            this.itemsSelect = new core.EventEmitter();
            this.onChildDevices = new core.EventEmitter();
            this.columns = this.deviceGridService.getDefaultColumns();
            this.pagination = this.deviceGridService.getDefaultPagination();
            this.actionControls = this.deviceGridService.getDefaultActionControls();
            this.bulkActionControls = this.deviceGridService.getDefaultBulkActionControls();
            this.withChildren = false;
            this.serverSideDataCallback = this.onDataSourceModifier.bind(this);
        }
        Object.defineProperty(DeviceGridComponent.prototype, "_columns", {
            set: function (value) {
                if (value) {
                    this.columns = this.deviceGridService.getUserConfiguredColumns(value);
                }
                else {
                    this.columns = this.deviceGridService.getUserConfiguredColumns(this.deviceGridService.getDefaultColumns());
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeviceGridComponent.prototype, "_pagination", {
            set: function (value) {
                if (value) {
                    this.pagination = value;
                }
                else {
                    this.pagination = this.deviceGridService.getDefaultPagination();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeviceGridComponent.prototype, "_infiniteScroll", {
            set: function (infiniteScroll) {
                this.infiniteScroll = infiniteScroll;
                this.pagination = this.deviceGridService.getInfiniteScrollPagination();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeviceGridComponent.prototype, "_actionControls", {
            set: function (value) {
                if (value) {
                    this.actionControls = value;
                }
                else {
                    this.actionControls = this.deviceGridService.getDefaultActionControls();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeviceGridComponent.prototype, "_bulkActionControls", {
            set: function (value) {
                if (value) {
                    this.bulkActionControls = value;
                }
                else {
                    this.bulkActionControls = this.deviceGridService.getDefaultBulkActionControls();
                }
            },
            enumerable: true,
            configurable: true
        });
        DeviceGridComponent.prototype.trackByName = function (_index, column) {
            return column.name;
        };
        DeviceGridComponent.prototype.onDataSourceModifier = function (dataSourceModifier) {
            return __awaiter(this, void 0, void 0, function () {
                var serverSideDataResult, _a, res, data, paging, filteredSize, size;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.deviceGridService.getData(dataSourceModifier.columns, dataSourceModifier.pagination, this.baseQuery, this.withChildren)];
                        case 1:
                            _a = _b.sent(), res = _a.res, data = _a.data, paging = _a.paging;
                            return [4 /*yield*/, this.deviceGridService.getCount(dataSourceModifier.columns, dataSourceModifier.pagination, this.baseQuery)];
                        case 2:
                            filteredSize = _b.sent();
                            return [4 /*yield*/, this.deviceGridService.getTotal(this.baseQuery)];
                        case 3:
                            size = _b.sent();
                            this.onColumnsChange.emit(dataSourceModifier.columns);
                            this.onDeviceQueryStringChange.emit(this.deviceGridService.getDeviceQueryString(dataSourceModifier.columns, this.baseQuery));
                            serverSideDataResult = {
                                res: res,
                                data: data,
                                paging: paging,
                                filteredSize: filteredSize,
                                size: size
                            };
                            if (this.dataCallback) {
                                serverSideDataResult = this.dataCallback(serverSideDataResult);
                            }
                            return [2 /*return*/, serverSideDataResult];
                    }
                });
            });
        };
        DeviceGridComponent.prototype.updateFiltering = function (columnNames, action) {
            var type = action.type;
            if (type === ngxComponents.FilteringActionType.ResetFilter) {
                this.dataGrid.clearFilters();
            }
            else {
                this.dataGrid.updateFiltering(columnNames, action);
            }
        };
        DeviceGridComponent.prototype.configChange = function (config) {
            this.deviceGridService.saveConfig(config);
        };
        DeviceGridComponent.ctorParameters = function () { return [
            { type: DeviceGridService }
        ]; };
        __decorate([
            core.Input()
        ], DeviceGridComponent.prototype, "dataCallback", void 0);
        __decorate([
            core.Input()
        ], DeviceGridComponent.prototype, "refresh", void 0);
        __decorate([
            core.Input()
        ], DeviceGridComponent.prototype, "title", void 0);
        __decorate([
            core.Input()
        ], DeviceGridComponent.prototype, "itemsSelectLimit", void 0);
        __decorate([
            core.Input()
        ], DeviceGridComponent.prototype, "loadMoreItemsLabel", void 0);
        __decorate([
            core.Input()
        ], DeviceGridComponent.prototype, "loadingItemsLabel", void 0);
        __decorate([
            core.Input('columns')
        ], DeviceGridComponent.prototype, "_columns", null);
        __decorate([
            core.Input('pagination')
        ], DeviceGridComponent.prototype, "_pagination", null);
        __decorate([
            core.Input('infiniteScroll')
        ], DeviceGridComponent.prototype, "_infiniteScroll", null);
        __decorate([
            core.Input('actionControls')
        ], DeviceGridComponent.prototype, "_actionControls", null);
        __decorate([
            core.Input()
        ], DeviceGridComponent.prototype, "selectable", void 0);
        __decorate([
            core.Input()
        ], DeviceGridComponent.prototype, "baseQuery", void 0);
        __decorate([
            core.Input('bulkActionControls')
        ], DeviceGridComponent.prototype, "_bulkActionControls", null);
        __decorate([
            core.Input()
        ], DeviceGridComponent.prototype, "showChildDevices", void 0);
        __decorate([
            core.Output()
        ], DeviceGridComponent.prototype, "onColumnsChange", void 0);
        __decorate([
            core.Output()
        ], DeviceGridComponent.prototype, "onDeviceQueryStringChange", void 0);
        __decorate([
            core.Output()
        ], DeviceGridComponent.prototype, "itemsSelect", void 0);
        __decorate([
            core.Output()
        ], DeviceGridComponent.prototype, "onChildDevices", void 0);
        __decorate([
            core.ViewChild(ngxComponents.DataGridComponent, { static: true })
        ], DeviceGridComponent.prototype, "dataGrid", void 0);
        DeviceGridComponent = __decorate([
            core.Component({
                selector: 'c8y-device-grid',
                template: "<c8y-data-grid\n  [title]=\"title\"\n  [loadMoreItemsLabel]=\"loadMoreItemsLabel\"\n  [loadingItemsLabel]=\"loadingItemsLabel\"\n  [columns]=\"columns\"\n  [pagination]=\"pagination\"\n  [infiniteScroll]=\"infiniteScroll\"\n  [actionControls]=\"actionControls\"\n  [selectable]=\"selectable\"\n  [bulkActionControls]=\"bulkActionControls\"\n  [serverSideDataCallback]=\"serverSideDataCallback\"\n  [itemsSelectLimit]=\"itemsSelectLimit\"\n  (itemsSelect)=\"itemsSelect.emit($event)\"\n  (onConfigChange)=\"configChange($event)\"\n  [refresh]=\"refresh\"\n  [showChildDevices]=\"showChildDevices\"\n  (onChildDevices)=\"withChildren=$event;onChildDevices.emit($event)\"\n>\n  <div class=\"c8y-empty-state\">\n    <h1 c8yIcon=\"search\"></h1>\n    <div>\n      <p>\n        <strong>{{ 'No matching devices.' | translate }}</strong>\n      </p>\n      <small>{{ 'Refine your search terms' | translate }}</small>\n    </div>\n  </div>\n  <ng-container *ngFor=\"let column of columns; trackBy: trackByName\">\n    <c8y-column [name]=\"column.name\"></c8y-column>\n  </ng-container>\n</c8y-data-grid>\n"
            })
        ], DeviceGridComponent);
        return DeviceGridComponent;
    }());

    var DeviceGridModule = /** @class */ (function () {
        function DeviceGridModule() {
        }
        DeviceGridModule = __decorate([
            core.NgModule({
                imports: [ngxComponents.CommonModule, ngxComponents.FormsModule, ngxComponents.DeviceStatusModule, ngxComponents.DataGridModule, assetsNavigator.AssetSelectorModule],
                declarations: [
                    DeviceGridComponent,
                    BaseFilteringFormRendererComponent,
                    GroupFilteringFormRendererComponent,
                    StatusCellRendererComponent,
                    NameCellRendererComponent,
                    ModelCellRendererComponent,
                    SerialNumberCellRendererComponent,
                    GroupCellRendererComponent,
                    RegistrationDateCellRendererComponent,
                    AlarmsCellRendererComponent,
                    SchemaFormComponent
                ],
                exports: [
                    DeviceGridComponent,
                    BaseFilteringFormRendererComponent,
                    GroupFilteringFormRendererComponent,
                    StatusCellRendererComponent,
                    NameCellRendererComponent,
                    ModelCellRendererComponent,
                    SerialNumberCellRendererComponent,
                    GroupCellRendererComponent,
                    RegistrationDateCellRendererComponent,
                    AlarmsCellRendererComponent,
                    SchemaFormComponent
                ],
                entryComponents: [
                    DeviceGridComponent,
                    BaseFilteringFormRendererComponent,
                    GroupFilteringFormRendererComponent,
                    StatusCellRendererComponent,
                    NameCellRendererComponent,
                    ModelCellRendererComponent,
                    SerialNumberCellRendererComponent,
                    GroupCellRendererComponent,
                    RegistrationDateCellRendererComponent,
                    AlarmsCellRendererComponent
                ],
                providers: [DeviceGridService]
            })
        ], DeviceGridModule);
        return DeviceGridModule;
    }());

    var CustomDeviceGridColumn = /** @class */ (function (_super) {
        __extends(CustomDeviceGridColumn, _super);
        function CustomDeviceGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            var self = _this;
            _this.name = 'custom';
            _this.header = ngxComponents.gettext('Custom');
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        exists: {
                            type: 'boolean',
                            default: false,
                            title: ngxComponents.gettext('Only rows where value is defined')
                        },
                        equals: {
                            type: 'array',
                            items: {
                                type: 'string'
                            }
                        }
                    }
                },
                form: [
                    {
                        key: 'exists'
                    },
                    {
                        key: 'equals',
                        title: ngxComponents.gettext('Only rows where value equals to:'),
                        add: ngxComponents.gettext('Or'),
                        items: [
                            {
                                key: 'equals[]',
                                notitle: true,
                                placeholder: ngxComponents.gettext('e.g. value, you can use an asterisk (*) as wildcard character')
                            }
                        ]
                    }
                ],
                getFilter: function (model) {
                    var filter = {};
                    if (model.exists) {
                        filter.__has = self.path;
                    }
                    if (model.equals) {
                        filter[self.path] = { __in: model.equals };
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            return _this;
        }
        Object.defineProperty(CustomDeviceGridColumn.prototype, "sortingConfig", {
            get: function () {
                return {
                    pathSortingConfigs: [{ path: this.path }]
                };
            },
            enumerable: true,
            configurable: true
        });
        return CustomDeviceGridColumn;
    }(BaseDeviceGridColumn));

    var TypeDeviceGridColumn = /** @class */ (function (_super) {
        __extends(TypeDeviceGridColumn, _super);
        function TypeDeviceGridColumn(initialColumnConfig) {
            var _this = _super.call(this, initialColumnConfig) || this;
            _this.name = 'type';
            _this.path = 'type';
            _this.header = ngxComponents.gettext('Type');
            _this.filterable = true;
            _this.filteringConfig = {
                schema: {
                    type: 'object',
                    properties: {
                        types: {
                            type: 'array',
                            items: {
                                type: 'string'
                            }
                        }
                    }
                },
                form: [
                    {
                        key: 'types',
                        title: ngxComponents.gettext('Show devices with type'),
                        add: ngxComponents.gettext('Or'),
                        items: [
                            {
                                key: 'types[]',
                                notitle: true,
                                placeholder: ngxComponents.gettext('e.g. MyType, you can use an asterisk (*) as wildcard character')
                            }
                        ]
                    }
                ],
                getFilter: function (model) {
                    var filter = {};
                    if (model.types.length) {
                        filter.type = { __in: model.types };
                    }
                    return filter;
                }
            };
            _this.sortable = true;
            _this.sortingConfig = { pathSortingConfigs: [{ path: 'type' }] };
            return _this;
        }
        return TypeDeviceGridColumn;
    }(BaseDeviceGridColumn));

    exports.AlarmsCellRendererComponent = AlarmsCellRendererComponent;
    exports.AlarmsDeviceGridColumn = AlarmsDeviceGridColumn;
    exports.BaseDeviceGridColumn = BaseDeviceGridColumn;
    exports.BaseFilteringFormRendererComponent = BaseFilteringFormRendererComponent;
    exports.CustomDeviceGridColumn = CustomDeviceGridColumn;
    exports.DeviceGridComponent = DeviceGridComponent;
    exports.DeviceGridModule = DeviceGridModule;
    exports.DeviceGridService = DeviceGridService;
    exports.GroupCellRendererComponent = GroupCellRendererComponent;
    exports.GroupDeviceGridColumn = GroupDeviceGridColumn;
    exports.GroupFilteringFormRendererComponent = GroupFilteringFormRendererComponent;
    exports.ImeiDeviceGridColumn = ImeiDeviceGridColumn;
    exports.ModelCellRendererComponent = ModelCellRendererComponent;
    exports.ModelDeviceGridColumn = ModelDeviceGridColumn;
    exports.NameCellRendererComponent = NameCellRendererComponent;
    exports.NameDeviceGridColumn = NameDeviceGridColumn;
    exports.RegistrationDateCellRendererComponent = RegistrationDateCellRendererComponent;
    exports.RegistrationDateDeviceGridColumn = RegistrationDateDeviceGridColumn;
    exports.SchemaFormComponent = SchemaFormComponent;
    exports.SerialNumberCellRendererComponent = SerialNumberCellRendererComponent;
    exports.SerialNumberDeviceGridColumn = SerialNumberDeviceGridColumn;
    exports.StatusCellRendererComponent = StatusCellRendererComponent;
    exports.StatusDeviceGridColumn = StatusDeviceGridColumn;
    exports.SystemIdDeviceGridColumn = SystemIdDeviceGridColumn;
    exports.TypeDeviceGridColumn = TypeDeviceGridColumn;
    exports.a = BaseFilteringFormRendererComponent;
    exports.b = GroupFilteringFormRendererComponent;
    exports.c = StatusCellRendererComponent;
    exports.d = NameCellRendererComponent;
    exports.e = ModelCellRendererComponent;
    exports.f = SerialNumberCellRendererComponent;
    exports.g = GroupCellRendererComponent;
    exports.h = RegistrationDateCellRendererComponent;
    exports.i = AlarmsCellRendererComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=c8y-ngx-components-device-grid.umd.js.map
